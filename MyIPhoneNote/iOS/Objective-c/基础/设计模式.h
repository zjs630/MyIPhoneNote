1，（一）代理模式（delagete模式）
应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。
优势：解耦合
敏捷原则：开放-封闭原则
实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。
列表row个数delegate
自定义的delegate

（二）观察者模式
应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。
优势：解耦合
敏捷原则：接口隔离原则，开放-封闭原则
实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。
kvo，键值对改变通知的观察者，平时基本没用过。
（三）MVC模式
应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。
优势：使系统，层次清晰，职责分明，易于维护
敏捷原则：对扩展开放-对修改封闭
实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。

（四）单例模式
应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。
优势：使用简单，延时求值，易于跨模块
敏捷原则：单一职责原则
实例：[UIApplication sharedApplication]。
注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。
java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。
object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，
返回的也只是此单例类的唯一静态变量。

（五）策略模式
应用场景：定义算法族，封装起来，使他们之间可以相互替换。
优势：使算法的变化独立于使用算法的用户
敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。
实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。
注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类
2，变化的行为抽象基类为，所有可变变化的父类
3，用户类的最终实例，通过注入行为实例的方式，设定易变行为
防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。

（六）工厂模式
应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。
优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。
敏捷原则：DIP依赖倒置原则
实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换
注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，
增 加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。


1，设计模式是一种设计模板，用于解决在特定环境中反复出现的一般性的问题。
它是一种抽象工具，在架构、工程、和软件开发领域相当有用。
设计模式的简单定义是 “特定环境下的特定问题的解决方案”。


1.委托
委托模式是一个对象周期性地向被指定为其委托的另一个对象发送消息，向其请求输入或者通知某件事情正在发生。
该模式可替换类继承来对可复用对象的功能进行扩展。
委托方法通常会集中在一起形成一份协议。 一份协议基本上就是一个方法的列表。
如果一个类遵循某个协议，则它要保证实现协议所要求的方法（有些方法可选择实现与否）。
委托协议规定了一个对象可以发送给委托的所有消息。

2.模型-视图-控制器
模型对象表示数据。例如，在一款游戏中，SpaceShips和Rockets是模型对象，在一个绘画应用中，Circles或Squares是模型对象。
视图对象知道如何显示数据（模型），并且它们有可能会允许用户对数据进行编辑。
控制器对象位于模型和视图之间。

3.目标-动作
目标-动作机制允许一个控件对象(诸如按键或滑动条) 向另外一个对象发送一条消息（即动作），
以之作为对某个用户事件（例如一个点击事件或者一个敲击事件）的响应。


4.外观（Facade）模式

外观模式针对复杂的子系统提供了单一的接口，不需要暴露一系列的类和API给用户，你仅仅公开一个简单统一的API。
这个API的使用者完全不需要关心背后的复杂性。这个模式非常适合有一大堆很难使用或者理解的类的情况。外观模式解耦了使用系统的代码和需要隐藏的接口和实现类。它也降低了外部代码对内部子系统的依赖性。当隐藏在外观之后的类很容易发生变化的时候，此模式就很有用了，因为当背后的类发生变化的时候，外观类始终保持了同样的API。
5.装饰器（Decorator）模式

装饰器模式在不修改原来代码的情况下动态的给对象增加新的行为和职责，它通过一个对象包装被装饰对象的方法来修改类的行为，这种方法可以做为子类化的一种替代方法。

在Objective-C中，存在两种非常常见的实现:Category(类别）和Delegation（委托）。
                                   
6.备忘录（Memento）模式
备忘录模式快照对象的内部状态并将其保存到外部。换句话说，它将状态保存到某处，过会你可以不破坏封装的情况下恢复对象的状态，也就是说原来对象中的私有数据仍然是私有的。

如：保存回复当前状态。NSUserDefaults是IOS提供的保存应用设置信息和数据的地方。
归档（Archiving）
归档是苹果对于备忘录模式的特定实现之一。这种机制可以转换一个对象到一个可保存的数据流中，过会可以在不暴漏私有属性给外部的情况下重建它们。

7.命令模式

命令模式将一个请求封装为一个对象。封装以后的请求会比原生的请求更加灵活，因为这些封装后的请求可以在多个对象之间传递，存储以便以后使用，还可以动态的修改，或者放进一个队列中。苹果通过Target-Action机制和Invocation实现命令模式。
                                   
