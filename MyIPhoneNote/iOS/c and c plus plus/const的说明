1，关键字const并不能把变量变为常量！在一个符号前加上const限定符只是表示这个符号不能被赋值。也就是它的值对于这个符号来说是只读的，
但它并不能放置通过程序的内部（甚至是外部）的方法来修改这个值。
	const最有用之处就是用它来限定函数的形参，这样该函数将不会修改实参指针所指的数据。但其它的函数却可能修改它。
2，const用在数据上
	const int limit ＝ 10；
	const int *limitp＝&limit；
	表示limitp是一个指向常量整型的指针，这个指针不能修改这个整型数。
	但是在任何时候，这个指针本身的值却可以改变。
	int i ＝ 27;
	limitp ＝&i;//这样它就指向了不同的地址。
3，const和*的组合通常只用于在数组形式的参数中模拟传值调用。它声称“我给你一个指向它的指针，但你不能修改它”。 
4
错误
int main(){
    int const a;//const声明的变量必须要进行初始化赋值。
    a=5;//编译器报错，因为声明为const的变量是不能修改的。
    printf("a=%d\n",a);
    teturn -0;
}
正确：
int main(){
    int const a = 5;//const声明的变量必须要进行初始化赋值。
    printf("a=%d\n",a);
    teturn -0;
}
5,
const int *a;//const 修饰指向的对象，a可变，a指向的对象不可变。
int const*a;//const 修饰指向的对象，a可变，a指向的对象不可变。

int *const a;//const 修饰指针a，a不可变，a指向的对象可变。
const int *const a;//指针a和a指向的对象都可变。

6,const   int   a与int   const   a没有区别，完全等价的，至于采用哪种写法，完全根据个人习惯。
但当const修饰的是指针时就有区别. 
const   int*   a 
int*   const   a   ; 
如果const位于星号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于星号的右侧，const就是修饰指针本身，即指针本身是常量


1 从const int i 说起
    你知道我们申明一个变量时像这样int i ；这个i是可能在它处重新变赋值的。如下：
int i=0;
//…
i=20;//这里重新赋值了
    不过有一天我的程序可能需要这样一个变量（暂且称它变量），在申明时就赋一个初始值。之后我的程序在其它任何处都不会再去重新对它赋值。那我又应该怎么办呢？用const 。
//**************
const int ic =20;
//…
ic=40;//这样是不可以的，编译时是无法通过，因为我们不能对const 修饰的ic重新赋值的。
//这样我们的程序就会更早更容易发现问题了。
//**************
    有了const修饰的ic 我们不称它为变量，而称符号常量，代表着20这个数。这就是const 的作用。ic是不能在它处重新赋新值了。
    认识了const 作用之后，另外，我们还要知道格式的写法。有两种：const int ic=20;与int const ic=20;。它们是完全相同的。这一点我们是要清楚。总之，你务必要记住const 与int哪个写前都不影响语义。有了这个概念后，我们来看这两个家伙：const int * pi与int const * pi ，按你的逻辑看，它们的语义有不同吗？呵呵，你只要记住一点，int 与const 哪个放前哪个放后都是一样的，就好比const int ic;与int const ic;一样。也就是说，它们是相同的。
    好了，我们现在已经搞定一个“双包胎”的问题。那么int * const pi与前两个式子又有什么不同呢？我下面就来具体分析它们的格式与语义吧！

2 const int * pi的语义
    我先来说说const int * pi是什么作用 （当然int const * pi也是一样的，前面我们说过，它们实际是一样的）。看下面的例子：
//*************代码开始***************
int i1=30;
int i2=40;
const int * pi=&i1;
pi=&i2;    //4.注意这里，pi可以在任意时候重新赋值一个新内存地址
i2=80;    //5.想想看：这里能用*pi=80;来代替吗？当然不能
printf( “%d”, *pi ) ;  //6.输出是80
//*************代码结束***************
语义分析： 
    看出来了没有啊，pi的值是可以被修改的。即它可以重新指向另一个地址的，但是，不能通过*pi来修改i2的值。这个规则符合我们前面所讲的逻辑吗？当然符合了！
    首先const  修饰的是整个*pi（注意，我写的是*pi而不是pi）。所以*pi是常量，是不能被赋值的（虽然pi所指的i2是变量，不是常量）。
    其次，pi前并没有用const 修饰，所以pi是指针变量，能被赋值重新指向另一内存地址的。你可能会疑问：那我又如何用const 来修饰pi呢？其实，你注意到int * const pi中const 的位置就大概可以明白了。请记住，通过格式看语义。哈哈，你可能已经看出了规律吧？那下面的一节也就没必要看下去了。不过我还得继续我的战斗！

3 再看int * const pi
    确实，int * const pi与前面的int const * pi会很容易给混淆的。注意：前面一句的const 是写在pi前和*号后的，而不是写在*pi前的。很显然，它是修饰限定pi的。我先让你看例子：
//*************代码开始***************
int i1=30;
int i2=40;
int * const pi=&i1;
//pi=&i2;    4.注意这里，pi不能再这样重新赋值了，即不能再指向另一个新地址。
      //所以我已经注释了它。
i1=80;    //5.想想看：这里能用*pi=80;来代替吗？可以，这里可以通过*pi修改i1的值。
    //请自行与前面一个例子比较。
printf( “%d”, *pi ) ;  //6.输出是80
//***************代码结束*********************
语义分析： 
    看了这段代码，你明白了什么？有没有发现pi值是不能重新赋值修改了。它只能永远指向初始化时的内存地址了。相反，这次你可以通过*pi来修改i1的值了。与前一个例子对照一下吧！看以下的两点分析
    1). pi因为有了const 的修饰，所以只是一个指针常量：也就是说pi值是不可修改的（即pi不可以重新指向i2这个变量了）(看第4行)。
    2). 整个*pi的前面没有const 的修饰。也就是说，*pi是变量而不是常量，所以我们可以通过*pi来修改它所指内存i1的值（看5行的注释）
    总之一句话，这次的pi是一个指向int变量类型数据的指针常量。
我最后总结两句：
    １）．如果const 修饰在*pi前则不能改的是*pi(即不能类似这样：*pi=50;赋值)而不是指pi。
    ２）．如果const 是直接写在pi前则pi不能改(即不能类似这样：pi=&i;赋值)。
请你务必先记住这两点，相信你一定不会再被它们给搞糊了。现在再看这两个申明语句int const *pi和int * const pi时，呵呵，你会头昏脑胀还是很轻松惬意？它们各自申明的pi分别能修改什么，不能修改什么？再问问自己，把你的理解告诉我吧，可以发帖也可以发到我的邮箱（我的邮箱yyf977@163.com）！我一定会答覆的。

３．补充三种情况。
    这里，我再补充以下三种情况。其实只要上面的语义搞清楚了，这三种情况也就已经被包含了。不过作为三种具体的形式，我还是简单提一下吧！

情况一：int * pi指针指向const int i常量的情况
//**********begin*****************
const int i1=40;
int *pi;
pi=&i1;　//这样可以吗？不行，VC下是编译错。
    //const int 类型的i1的地址是不能赋值给指向int 类型地址的指针pi的。否则pi岂不是能修改i1的值了吗！
pi=(int* ) &i1;　　//　这样可以吗？强制类型转换可是C所支持的。
      //ＶＣ下编译通过，但是仍不能通过*pi=80来修改i1的值。去试试吧！看看具体的怎样。
//***********end***************

情况二：const int * pi指针指向const int i1的情况
//*********begin****************
const int i1=40;
const int * pi;
pi=&i1;//两个类型相同，可以这样赋值。很显然，i1的值无论是通过pi还是i1都不能修改的。
//*********end*****************

情况三：用const int * const pi申明的指针
//***********begin****************
int i
const int * const pi=&i;//你能想像pi能够作什么操作吗？pi值不能改，也不能通过pi修改i的值。因为不管是*pi还是pi都是const的。
//************end****************